---
slug: "getting-started"
date: "2022-01-25"
title: "Building a Web Server with Node.js and Express.js"
author:
  name: "jeysen-freedman"
  bio: "Full Stack Web Developer"
  image: ../../media/jeysen-freedman.jpg
tags:
  [
    "nodejs",
    "npm",
    "semver",
    "javascript",
    "getting started",
    "backend",
    "web server",
    "api",
    "expressjs",
    "coding",
  ]
summary: ""
pillar: "full-stack-nodejs"
pillarContent:
  image: ""
  pillarTitle: "Building a Full Stack Node.js Application | The Step-by-Step JavaScript Developer's Guide"
  text: "<em>'Building a Full Stack Node.js Application - The Step-by-Step JavaScript Developer's Guide'</em> is an ongoing series on full stack Node.js web development.  Each step in the series covers a variety of web development topics, including: back-end development, front-end development, best practices, useful libraries, design patterns, error handling, UI/UX design, and much more."
image:
  path: ./media/web-server.png
  alt: "A web server"
  caption: 'Photo by <a href="https://unsplash.com/@tvick?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"><i>Taylor Vick</i></a> on <a href="https://unsplash.com/s/photos/web-server?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"><i>Unsplash</i></a>
  '
---

> This is part two of **"Building a Full Stack Node.js Application - The Step-by-Step JavaScript Developer's Guide"**. [Find the full series here](/blog/full-stack-nodejs).

## Introduction

In the previous article you learned that _Node.js_ gives us the ability to run JavaScript outside the browser and specifically, to build production-grade backend web servers.

You also learned that you have access to a million plus different _packages_ on the _npm registry_ for use in your project via the _node package manager_ (_npm_).

To continue with _Part 2_, you should have a Node.js project initialized with _Express.js_ and _ES Modules_ configured in _package.json_. For a recap, see [Part 1](/blog/full-stack-nodejs/getting-started-with-full-stack-node-js-development/#installing-expressjs) starting from _Installing Express.js_.

We will begin this article with an overview of web servers and a few core Node.js modules. If you're already familiar with these topics you can jump right into [express](#express).

## Web Server Basics

A web server is simply a computer whose primary responsibility is receiving and responding to external requests. These requests typically come from web clients, aka your web browser (Chrome, Firefox, Safari). The _server_ receives and responds to requests from a _client_ via **HTTP**, or **HyperText Transfer Protocol**.

> A server is sometimes called a _host_ because it _hosts_ or _stores_ files (web pages and other files) that can be made available to clients.

When you want to visit a website, you enter its URL into your web browser. A URL is just a human readable way to contact a specific server and it consists of a **domain name** plus some additional information.

For example, when you want to use Google Search, you enter `www.google.com` into your browser. This is called the **domain name** and it exists only because we humans remember words much better than numbers. In reality, a **domain name** is mapped to a server's _IP address_, a number that uniquely identifies it on the internet.

> The service responsible for figuring out what _domain name_ belong to which _IP address_ is called the **Domain Name System (DNS)**.

### Web 1.0

Traditionally, when you entered just a website's domain name (`www.example.com`) into your web browser, you were requesting the web page stored at the hosting server's **root directory**, usually called the **index page**. Although it isn't always shown, a _trailing slash_ is always assumed, so `www.example.com` and `www.example.com/` are equivalent.

> The index page has the special name of **index.html**

Similar to how your computer stores files at specific _paths_, a basic server stores and retrieves files via its **file system**. When your URL contains additional information, e.g. `www.example.com/new/`, you are being more specific about what you want the server to return. In this case, the server would return the index page located in the _"new"_ folder.

> If you entered `www.example.com/new/thing.html` you would get the **thing.html** page located in the _new_ folder.

In the first version of the web (Web 1.0), this was basically all there was to it. You requested a file from a server based on the URL you provided, and the server responded accordingly.

> This is a simplified explanation, and in fact, web masters were creative in trying to add more functionality to websites at this time. The major issue was a lack of standardization (everyone was using different methods to accomplish the same goals) which is what fueled the leap to Web 2.0.

### Web 2.0

As the web evolved, simply viewing web pages wasn't going to cut it. Users wanted more from their web browsing experience, and why shouldn't they? After all, it's in our nature to want to improve.

Web 2.0 introduced a standardized way for users to not just consume content, but to create it too.

To manage the ability to _create_, _read_ (retrieve), _update_, and _destroy_ (delete) content (aka **CRUD**), HTTP was expanded to include additional features.

Here began the era of Web APIs, with the most well known being the **REST API**.

> **REST** - aka "**Re**presentational **S**tate **T**ransfer - is a standard for mapping CRUD functionality onto HTTP. Specifically, the additional HTTP features called **HTTP verbs**

**The main HTTP verbs are mapped to CRUD as follows:**

- **POST** equals _create_
- **GET** equals _read_
- **PUT/PATCH** equals _update_
- **DELETE** equals _destroy_

With these enhancements, web servers became more powerful but also more complex. Web 2.0 wasn't just about serving files in response to requests, but also managing CRUD operations, communicating with databases, generating and serving dynamic content, and more.

## Node.js

Since a primary application of Node.js is to build a web server, let's build one ourselves. A Web 1.0 type server is trivial to set up, so we will jump right into building a server that can handle full CRUD operations.

Node.js ships with several _core modules_ but the few most commonly used to build a web server are the **path**, **url**, **fs**, and **http** modules.

Let's combine these with _express_ and build a web server.

> The **http** module is the core web server module included with Node.js, but since **express** is built on it, and abstracts a lot of its functionality making the process much easier, we won't dig too much into it here.

### The path and url modules

The **path** module helps Node.js applications use the correct file path needed to access files on its file system. The **url** module provides a helper function for resolving the current directory when using ES Modules. This is useful because different operating systems use different formats for structuring file paths.

> For example, Linux paths are separated by a **forward slash** `/` while Windows paths can use either forward `/` or back `\` slashes (but can't combine the two in a single path).

> A Windows path might look like: `C:\Users\jeysen\node-tutorial`

> A Linux path might look like: `/home/jeysen/node-tutorial`

If you develop your web application on a Windows computer and use _hard coded_ file paths, you will run into issues when you deploy it on a Linux machine. So we use these modules to make our file paths OS agnostic.

> The majority of web applications are deployed to computers running a Linux OS.

Let's see how we can accomplish this.

Create a file called **path.js** and add the following code:

```js
import { fileURLToPath } from "url";
import path from "path";

console.log(import.meta.url); // logs file:///C:/Users/jeysen/node-tutorial/path.js
console.log(fileURLToPath(import.meta.url)); // logs C:\Users\jeysen\node-tutorial\path.js
console.log(path.dirname(fileURLToPath(import.meta.url))); // logs C:\Users\jeysen\node-tutorial
```

Run the code from the CLI with the `node path.js` command.

If you study the logs above or in your terminal, you can see that we start with the current file path provided by `import.meta.url` and use the `fileURLToPath` function followed by the `path.dirname` method to transform our file path to point to the current directory (folder) we are in (also called the working directory).

Since we will always access files _relative_ to the file we are working in, we will want to assign the result of this transformation to a variable, traditionally called `__dirname`:

```js
const __dirname = path.dirname(fileURLToPath(import.meta.url));
console.log(__dirname); // logs C:\Users\jeysen\node-tutorial
```

We can now access files anywhere on the file system, regardless of OS, by using the `.join` method on the _path_ object we imported earlier.

We supply `path.join` with our working directory as the first argument, the file we want as the last argument, and any navigation steps in between. The **join** method will join these argument together and normalize the resulting path.

> Note that the arguments provided to join must be **strings**.

For example, if you had the following project structure:

```
/jeysen
    bio.txt
    /node-tutorial
        path.js
        /media
            image.jpg
```

You could access the `image.jpg` file with:

```js
path.join(__dirname, ".", "media", "image.jpg"); // results in C:\Users\jeysen\node-tutorial\media\image.jpg
```

You could access the `bio.txt` file with:

```js
path.join(__dirname, "..", "bio.txt"); // results in C:\Users\jeysen\bio.txt
```

You can use these techniques to navigate anywhere in your project's directory.

Let's apply this to reading and writing files to the file system.

### The fs module

The **fs** or _file system module_ gives Node.js applications the ability to read and write files to the file system.

File system access can be either **synchronous** or **asynchronous**. We will first look at the **synchronous** approach to writing/reading files and then implement the _promise-based_ **asynchronous** approach.

#### fs synchronous operations

Create a file called `fs.js` with the following code:

```js
import { fileURLToPath } from "url";
import path from "path";
import fs from "fs";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
```

Now create a folder named "documents" which we will write a text file to.

Add the following code to `fs.js` and run it from the CLI with `node fs.js`:

```js
fs.writeFileSync(
  path.join(__dirname, ".", "documents", "hello.txt"),
  "Hello World!"
);

const data = fs.readFileSync(
  path.join(__dirname, ".", "documents", "hello.txt"),
  { encoding: "ascii" }
);

console.log(data); // logs "Hello World!
```

As you can see from the above code, we use the `writeFileSync` and `readFileSync` to _synchronously_ write and read from the file system. If you look in the _documents_ folder you can confirm the _hello.txt_ file was created.

Because we are creating a text file, we specify the encoding as **"ascii"**. If you didn't provide an _encoding type_ then the `readFileSync` command would return a **Buffer** which is basically a container for raw data. Node offers a variety of encoding types for you to choose from depending on your application.

#### fs asynchronous operations

Since Node.js is single threaded, using synchronous fs operations will block the main thread. This is bad news, but we can easily fix this by taking advantage of Node's asynchronous nature.

Modern Node offers a **promise-based** alternative to synchronous fs operations. If you aren't familiar with promises, they basically allow you to write readable async code, whereas in the past you had to use a nested mess of "callback functions" aka _callback hell_.

Let's move forward with the modern promise-based approach.

Change your **fs** import to `import fs from "fs/promises";`.

Rewrite your code in `fs.js` to:

```js
fs.writeFile(path.join(__dirname, ".", "documents", "todo.txt"), "Hello World!")
  .then(() => {
    console.log("File written!");

    return fs.readFile(path.join(__dirname, ".", "documents", "todo.txt"), {
      encoding: "ascii",
    });
  })
  .then((data) => console.log(data)) // logs "Hello World!"
  .catch((err) => console.log(err));

console.log("First!"); // logs "First!" before "File Written!" or "Hello World!"
```

Running this code with `node fs.js` will give the same result as before, but this time the main thread will not be blocked. We can prove this by adding a `console.log` statement _after_ the async code, as shown above.

This is an upgrade from the synchronous approach to fs operations, but we can make the code even more readable by moving from **.then/.catch syntax** to **async/await syntax** enclosed in a **try/catch block**.

Since we can't use the `await` keyword at the top level (outside a function) we will encapsulate the **fs** code in a function and make it flexible by providing both the filename and content as function arguments. We will also `export` the function so we can use it elsewhere.

```js
export async function writeThenRead(filename, content) {
  try {
    await fs.writeFile(
      path.join(__dirname, ".", "documents", filename),
      content
    );

    console.log("File written!");

    const data = await fs.readFile(
      path.join(__dirname, ".", "documents", filename),
      {
        encoding: "ascii",
      }
    );

    return data;
  } catch (err) {
    console.log(err);
  }
}

console.log(writeThenRead("todo.txt", "Hello World!")); // logs "Hello World!"
```

Let's expand on these fs operations by integrating them into a web server.

### The http module

Although we will use _express_ to build a more complex web server, let's take a quick look at the **http module** to see how it works.

Create a file called `https.js` and add the following:

```js
import http from "http";

http
  .createServer((request, response) => {
    console.log("Received a request!");
  })
  .listen(3000, () => console.log("Server listening on Port 3000"));
```

As you can see, all a server does is listen for HTTP traffic on a specific port (port 3000 in this case) which it receives as a **request object**. We use the **request object** to extract information regarding the request and usually data sent by the client. To reply to a request we use the **response object**. The request and response objects are usually shortened to just **req** and **res** respectively.

If you run this code with `node http.js` and then navigate to `http://localhost:3000/` in your browser, you should see _"Received a request!"_ logged to your console.

Since the server is not sending anything back to the client, your browser will hang on loading until it finally times out.

To send a reply to the client we can first write some text to the response object, and then send it:

```js
http
  .createServer((req, res) => {
    res.write("Hello!");
    res.end();
  })
  .listen(3000, () => console.log("Server listening on Port 3000"));
```

You should now see "Hello!" when you access `http://localhost:3000/` from your browser.

> Make sure you restart your server (CTRL + c to exit from the CLI) and start it up again to see the change.

> Note that you need to call **res.end()** to actually send the response.

Now let's create a text file for every incoming request using the `writeThenRead` function and then return its contents to the client. We will keep track of the request number in the `requestNumber` variable.

```js
import http from "http";
import { writeThenRead } from "./fs.js";

let requestNumber = 0;

http
  .createServer(async (req, res) => {
    requestNumber++;
    const message = await writeThenRead(
      `request-number-${requestNumber}.txt`,
      `You are request number ${requestNumber}!`
    );
    res.write(message);
    res.end();
  })
  .listen(3000, () => console.log("Server listening on Port 3000"));
```

If you start the server with `node http.js` and try connecting to it via the web browser, you should receive the text: _"You are connection number 1!"_.

You may notice that you are actually generating **two .txt files** for every request you make to your server. This is because modern browsers will make additional requests on their own. In this case, the browser is looking for the **favicon** - the small image shown at the top of the browser window, on the window's tab.

To prevent this, you can wrap your code in an `if` check and only run your code when the request isn't for the favicon.

```js
if (req.url !== "/favicon.ico") {
  requestNumber++;
  const message = await writeThenRead(
    `request-number-${requestNumber}.txt`,
    `You are request number ${requestNumber}!`
  );
  res.write(message);
  res.end();
}
```

Now that you've gotten a taste for the basic http module, let's build something complex with **express**.

## Express

Alright, the moment you've been waiting for has finally arrived. It's time to dig into **express**. If you've read everything up till now, congratulations! If not, that's cool too :).

Let's build this thing.

The API will:

- Receive input from a user and store this data in a file on the server's file system
- Serve this data back to a client upon request
- Update this data upon request
- Delete this data upon request
- Return a list of files in the file system
- Include middleware for data transformation, serving static files, logging, and error handling

As a bonus, we will build the frontend (responsible for collecting the user input) in [React](https://reactjs.org/) via CDN scripts.

> Since we aren't building a complex React app, we won't use the "create-react-app" CLI tool.

> A CDN, or "content delivery network", is a globally distributed network that provides high speed access to static files.

The project structure will look like:

```
/project
  index.js
  utils.js
  package.json
  package-lock.json
  /node_modules
  /public
    index.html
```

We've got our work cut out for us but to get started, first make sure you are in the working directory that includes your **package.json** file with **express** installed.

Add the following code to **index.js**:

```js
import { fileURLToPath } from "url";
import path from "path";
import fs from "fs/promises";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

import express from "express";
const app = express();

app.listen(3000, () => {
  console.log("Server running on port 3000");
});
```

The only thing new here is that we created our express app by calling `express()` and assigned it to the `app` variable. We can then call the `.listen()` method to start our server, just like we did with the `http` module.

Next, create the **public folder** and within it, the **index.html page**.

If you're using VS Code, you can open up the **index.html** page and type `!` to get HTML boilerplate code, then add the `h1`, `div` and `script` tags shown below.

Or, copy and paste the following HTML code:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Express API</title>
  </head>
  <body>
    <h1>Express</h1>
    <div id="app"></>
  </body>
</html>
<script>
  // React code will go here
</script>
```

At this point, if we started the server with `node index.js` and tried to access `http://localhost:3000/` from the browser we would see:

```
Cannot GET /
```

Like we talked about earlier, when we try to access a web page from the browser, the most basic thing we are trying to do is request a file. But we haven't told **express** to serve any files yet.

Let's make this happen by implementing our first middleware functions.

> Middleware functions are just functions that have access to the request and response objects for **every** request/response.

> Middleware functions execute in the order they are defined.

To implement a middleware function we call the `.use()` method on the `app` object, and provide it a function that gets the _request_ and _response_ objects in addition to a special function called `next`. The `next` function has to be explicitly called from middleware or _express_ will not proceed and the connection will timeout.

The first middleware will simply log information about the request's **HTTP method** and **url** to the console.

> Recall the common HTTP methods are GET, POST, PUT/PATCH, and DELETE

Add the following to **index.js**:

```js
app.use((req, res, next) => {
  console.log(`Request: ${req.method} ${req.url}`);
  next();
});
```

Next, we will use middleware to serve our static assets by calling express's built in middleware function `.static()`:

> Note that the only static asset we have right now is the index.html file.

```js
app.use(express.static(path.join(__dirname, ".", "public")));
```

Now, run your server with `node index.js` and visit `http://localhost:3000/` from your browser. You should see **Express** written on the web page.

In your console, you should see the following:

```
$ node index.js
Server running on port 3000
Request: GET /
```

> You can see that requesting a web page is a GET request and like we talked about earlier, the **url** points to a location on the server and begins **after** the **domain name**.

add app.get('/\*') route that epxlicitly sends the index.html file
